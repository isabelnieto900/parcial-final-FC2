\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{listings} % Para incluir código
\usepackage{caption}

\title{Investigación: Generación de Números Aleatorios y Caminatas Aleatorias}
\author{Física Computacional II - Grupo [Número/Nombre del Grupo]}
\date{\today}

\begin{document}
\maketitle

\section{Números Pseudoaleatorios}
\subsection{Concepto y Requisitos}
Los números pseudoaleatorios (PRNG por sus siglas en inglés, Pseudo-Random Number Generators) son secuencias de números generadas por algoritmos determinísticos que aparentan ser aleatorias. Aunque no son verdaderamente aleatorios (ya que, dada la semilla inicial, la secuencia es reproducible), pueden pasar diversas pruebas estadísticas de aleatoriedad.

Requisitos clave para un buen PRNG:
\begin{itemize}
    \item \textbf{Periodo largo:} La secuencia debe ser muy larga antes de repetirse.
    \item \textbf{Uniformidad:} Los números deben estar distribuidos uniformemente en el rango deseado (e.g., [0,1)).
    \item \textbf{Independencia:} Los números sucesivos deben parecer independientes entre sí (baja correlación).
    \item \textbf{Eficiencia computacional:} Deben poder generarse rápidamente.
    \item \textbf{Reproducibilidad:} Dada la misma semilla, se debe generar la misma secuencia (importante para depuración y verificación).
    \item \textbf{Robustez estadística:} Deben pasar un conjunto amplio de pruebas estadísticas de aleatoriedad.
\end{itemize}

\subsection{Ejemplo de Generador Simple en C++ y Correlaciones}
Un generador congruencial lineal (LCG) es un ejemplo simple:
$X_{n+1} = (a X_n + c) \pmod m$
donde $X_n$ es el n-ésimo número, $a$ es el multiplicador, $c$ el incremento, y $m$ el módulo.
Los números normalizados se obtienen como $U_n = X_n / m$.

\begin{lstlisting}[language=C++, caption=Ejemplo de LCG simple, basicstyle=\footnotesize\ttfamily]
#include <iostream>
#include <vector>
#include <fstream>

class LCG {
private:
    unsigned long long seed;
    unsigned long long a; // multiplicador
    unsigned long long c; // incremento
    unsigned long long m; // modulo

public:
    LCG(unsigned long long seed_val, unsigned long long mult,
        unsigned long long incr, unsigned long long modu)
        : seed(seed_val), a(mult), c(incr), m(modu) {}

    double random_uniform() {
        seed = (a * seed + c) % m;
        return static_cast<double>(seed) / m;
    }
};

int main() {
    // Parámetros de Numerical Recipes (no necesariamente los mejores, solo ejemplo)
    LCG generador(12345, 1664525, 1013904223, 4294967296);

    std::ofstream outfile("results/lcg_output.dat");
    std::ofstream outfile_corr("results/lcg_correlation.dat");

    double u_anterior = generador.random_uniform();
    outfile << u_anterior << std::endl;

    for (int i = 0; i < 10000; ++i) {
        double u_actual = generador.random_uniform();
        outfile << u_actual << std::endl;
        outfile_corr << u_anterior << " " << u_actual << std::endl;
        u_anterior = u_actual;
    }
    outfile.close();
    outfile_corr.close();
    return 0;
}
\end{lstlisting}
La visualización de correlaciones se puede hacer graficando $U_n$ vs $U_{n+1}$. Para un buen generador, los puntos deberían llenar el cuadrado unitario de forma uniforme, sin estructuras aparentes. Los LCG simples a menudo muestran estructuras de hiperplanos.

\subsection{Uso y Precauciones de los RNG en Simulaciones Físicas}
Los RNG son cruciales en simulaciones que involucran procesos estocásticos (Monte Carlo, movimiento Browniano, etc.).
Precauciones:
\begin{itemize}
    \item \textbf{Calidad del generador:} Usar generadores probados y de alta calidad. Evitar \texttt{rand()} de C estándar para simulaciones serias debido a su corto periodo y posibles correlaciones.
    \item \textbf{Semilla (Seed):} Siempre inicializar (sembrar) el generador. Para reproducibilidad, usar una semilla fija. Para corridas "diferentes", usar una semilla basada en el tiempo o \texttt{std::random\_device}.
    \item \textbf{Correlaciones:} Tener cuidado con las correlaciones, especialmente en dimensiones altas. Generadores deficientes pueden introducir artefactos.
    \item \textbf{Periodo:} Asegurarse de que el periodo del generador sea mucho mayor que el número de números aleatorios necesarios para la simulación.
    \item \textbf{Múltiples streams:} Si se necesitan múltiples secuencias independientes (e.g., en paralelo), usar técnicas adecuadas para generar sub-secuencias o generadores con parámetros diferentes y probados.
\end{itemize}

\subsection{Descripción del Generador MIXMAX}
MIXMAX (Matrix Recursive Maximum Period Generator) es una familia de generadores de números pseudoaleatorios desarrollados por G. Savvidy y K. Savvidy. Se caracteriza por:
\begin{itemize}
    \item \textbf{Periodo extremadamente largo:} Puede alcanzar periodos del orden de $10^{4000}$ o más, dependiendo de la dimensión de la matriz utilizada.
    \item \textbf{Buenas propiedades estadísticas:} Ha pasado rigurosas baterías de pruebas como TestU01.
    \item \textbf{Basado en recursión matricial:} La generación de números se basa en una operación matricial sobre un vector de estado, módulo un primo grande. La matriz tiene propiedades especiales que garantizan el periodo largo y buenas propiedades de mezcla.
    \item \textbf{Eficiencia:} Puede ser muy eficiente, especialmente en versiones optimizadas.
    \item \textbf{Teoría sólida:} Su diseño se basa en principios de sistemas dinámicos y teoría de números.
\end{itemize}
Es considerado uno de los generadores de más alta calidad disponibles actualmente para simulaciones científicas exigentes.

\section{Caminatas Aleatorias (Random Walks)}
\subsection{Definición y Relación con Difusión}
Una caminata aleatoria es un proceso matemático que describe una trayectoria consistente en una sucesión de pasos aleatorios en algún espacio (e.g., una retícula).
\begin{itemize}
    \item \textbf{Simple (SRW):} En cada paso, el caminante elige una dirección al azar con igual probabilidad entre las opciones disponibles.
    \item \textbf{Relación con difusión:} El desplazamiento cuadrático medio $\expval{R_N^2}$ de una caminata aleatoria simple de $N$ pasos de longitud $l$ en $d$ dimensiones es típicamente $\expval{R_N^2} \propto Nl^2$. Si cada paso toma un tiempo $\Delta t$, entonces el tiempo total es $t = N\Delta t$. Así, $\expval{R_t^2} \propto t$, que es la firma de un proceso difusivo. El movimiento Browniano es un ejemplo físico de un proceso modelado por una caminata aleatoria en el límite continuo.
\end{itemize}

\subsection{Comparación de Generadores en C++}
\begin{itemize}
    \item \texttt{rand()} (\texttt{<cstdlib>}): Parte del estándar C. Generalmente no recomendado para simulaciones serias.
        \begin{itemize}
            \item Pros: Simple de usar, universalmente disponible.
            \item Contras: Calidad a menudo pobre (LCG simple), periodo corto (e.g., $2^{31}-1$ para \texttt{RAND\_MAX}), puede tener correlaciones significativas. No es thread-safe sin precauciones. La distribución no está garantizada como uniforme en todos los bits.
        \end{itemize}
    \item \texttt{drand48()} (familia, \texttt{<cstdlib>} en sistemas POSIX):
        \begin{itemize}
            \item Pros: Mejor calidad que \texttt{rand()} en muchos sistemas, periodo más largo ($2^{48}$). Genera dobles en [0,1).
            \item Contras: No es parte del estándar C++, disponibilidad depende del sistema (POSIX). Puede tener problemas de thread-safety.
        \end{itemize}
    \item Biblioteca \texttt{<random>} (C++11 y posterior): Proporciona un framework mucho más robusto y flexible.
        \begin{itemize}
            \item Pros:
                \begin{itemize}
                    \item Múltiples motores de generación (e.g., \texttt{std::mt19937} - Mersenne Twister, \texttt{std::ranlux48}).
                    \item Periodos muy largos (e.g., $2^{19937}-1$ para MT19937).
                    \item Excelentes propiedades estadísticas para motores como MT19937.
                    \item Separación entre motores (generan bits "crudos") y distribuciones (e.g., \texttt{std::uniform\_int\_distribution}, \texttt{std::normal\_distribution}, \texttt{std::exponential\_distribution}).
                    \item Permite control de semillas y reproducibilidad. Objetos generadores pueden ser instanciados localmente, mejorando la gestión en programas complejos y multihilo.
                \end{itemize}
            \item Contras: Ligeramente más complejo de configurar inicialmente que un simple \texttt{rand()}. El rendimiento puede variar entre motores, pero los buenos suelen ser eficientes.
        \end{itemize}
\end{itemize}
\textbf{Recomendación:} Para simulaciones físicas en C++, siempre se debe preferir la biblioteca \texttt{<random>} sobre \texttt{rand()} o \texttt{drand48()}. El generador \texttt{std::mt19937} es una excelente opción de propósito general.

\end{document}
